## 1. Lists

```cs
// this creates a new empty list:
List<int> numbers = new List<int>(); // []
numbers.Add(100); // [100]
numbers.Add(200); // [200]
numbers.Add(300); // [300]
var bigNumber = 500;
// you can add numbers multiple times:
numbers.Add(bigNumber); // [100, 200, 300, 500, 500]
numbers.Add(bigNumber); // [100, 200, 300, 500, 500]
// this will print "3"
Console.WriteLine($"number count: {numbers.Count}");
// this accesses the second number (200):
var number1 = numbers[1];
// this will remove the second number (200) from the list:
numbers.RemoveAt(1);
// this removes the first instance of the given number
// it's a convenience funtion that searches for your number and then
// removes it from the list
// bad performance, because is has to check each element sequentially.
numbers.Remove(bigNumber); // [100, 300, 500]

// why even use arrays when you have lists?
// there is not amny reasons to be honest
// arays have slightly better performance
// also, they prevent the size to be changed
```

- **Offer these functions:**
  - `Add(Item item)` to add a new Item to the end of the list
  - `RemoveAt(int index)` to remove an item at the given index
  - `GetAt(int index)` returns an item at the given index
  - `Count()` returns the amount of items in the list
- `(Remove(Item item)`: Remove the given item from the list. Bad performance.)
- Lists are Dynamic Arrays
- They Resize automatically

---

## 2. Queues

```cs
//this creates a new empty Queue:
Queue<int> numbers = new Queue<int>(); // []
numbers.Enqueue(100); // [100]
numbers.Enqueue(200); // [100, 200]
numbers.Enqueue(300); // [100, 200, 300]
var bigNumber = 500;
// you can add numbers multiple times:
numbers.Enqueue(bigNumber); // [100, 200, 300, 500]
numbers.Enqueue(bigNumber); // [100, 200, 300, 500, 500]
// this will print "5"
Console.WriteLine($"number count: {numbers.Count}");
// you can look at the first number (100):
var number1 = numbers.Peek();
// this will remove the first number (100):
var number2 = numbersDequeue(); // [200, 300, 500, 500]
// the previously second number (200) is now the first:
```

- **Offer these functions:**
  - `Enqueue(Item item)` adds an item to the back
  - `Peek()` returns the item in the beginning
  - `Dequeue()` removes and returns the item in the beginning
  - `Count()` returns the amount of items
- **Queues are called FIFO:**
  - First In First Out

---

## 3. Stacks

```cs
// this creates a new empty stack:
Stack<int> numbers = new Stack<int>(); // []
numbers.Push(100); // [100]
numbers.Push(200); // [200, 100]
numbers.Push(300); // [300, 200, 100]
var bigNumber = 500;
// you can add numbers multiple times:
numbers.Push(bigNumber); // [500, 300, 200, 100]
numbers.Push(bigNumber); // [500, 500, 300, 200, 500]
// this will pring "5"
Console.WriteLine($"number count: {numbers.Count}");
// you can look at the latest number (500):
var number1 = numbers.Peek();
// this will remove the latest number (500):
var number2 = numbers.Pop(); // [500, 300, 200, 100]
// the previously second number (200) is now the latest:
var number3 = numbers.Pop(); // [500, 200, 100]

// stacks are also called "LIFO":
// Last In First Out
// that means that whatever goes last also comes out first
// it's very useful if you want a series of things to be
// handled one after another, but always begin with what's new first
```

- **Offer these functions:**
  - `Push(Item item)` adds an item to the top
  - `Peek()` returns the item at the top
  - `Pop()` removes and returns the item at the top
  - `Count()` returns the amount of items
- **Stacks are called LIFO:**
  - Last In First Out

---

## 4. HashSets

```cs
// this creates a new empty HashSet:
HashSet<int> numbers = new HashSet<int>(); // []
numbers.Add(100); // [100]
numbers.Add(200); // [100, 200]
numbers.Add(300); // [100, 200, 300]
var bigNumber = 500;
// you can add each number only once:
numbers.Add(bignumber); // [100, 200, 300, 500]
numbers.Add(bignumber); // [100, 200, 300, 500]
// this will print "4"
Console.WriteLine($"number count: {numbers.Count}");
// you can check if a number is contained:
var has200 = numbers.Contains(200); // true
var has7 = numbers.Contains(7); // false
// you can remove any number again:
numbers.Remove(300); // [100, 200, 300]

// HashSets are Indexed Containers.
// for each time a Hash is generated, anf through this hash, the item can be found instantly
// no searching is involved, that's a very strong feature and helps us to keep track of things that are in this collection.
```

- **Offer these functions:**
  - Add(Item item) adds an item to the Hashset, if itâ€˜s not in the HashSet, yet.
  - Remove(Item item) removes the item from the Hashet, if it is the HashSet.
  - bool Contains(Item item) returns true, if the item is part of this HashSet
  - Count() returns the amount of items
- HashSets are Lists of Unique Elements
- They avoid Duplicates
- They have great performance for finding and removing any item!

---

## 5. Dictionary

```cs
//creating a new dictionary with two genric types:
// TKey, here string, is the key of the dictionary
// TValue, here Unit, is the value type of the dictionary
// it is used to map the Units by their names
// in other words: it's a dictionary to look up units by their names
Dictionary<string, Unit> units = new Dictionary<string, Unit>();
// adding an item to the dictionary, Key must be UNSED!
units.Add("Eva", new Unit("Eva")); // {"Eva":(unit)}
// returns false because an element with the same key exists
units.TryAdd("Eva", new Unit("Eva")); // {"Eva":(unit)}
// this will set the item for that key. Overrides the existing key.
units.Add("Adan", new Unit("Adam")); // {"Eva":(u) "Adam":(u)}
units.Remove("Adam"); // {"Eva":(u)}
var hasEva = units.ContainsKey("Eva"); // will return true
var Eva = units["Eva"];
// this will try to read a value and assign it to the variable
if(units.TryGetValue("Adam", out var adam)) {
// this code only gets executes if the value exists
// so in this case it won't be executed.
}
```

- Special collection for mapping objects by keys.
- Useful, whenever you want to look things up by their:
  - Names
  - Ids
  - Or other Keys
- Same performance as HashSets:
  - Complexity O(1)

---

## 6. ForEach

```cs
// implementing IEnumerable or IEnumerable<T>
// allows the usage of foreach
public class UnitCamp : IEnumerable<Unit>
   List<Unit> units;
   
   public void TrainUnit() {
      this.units.Add(new Unit("Unit"));
      }
// here I just return the enumerator from the internal list
// you can write your own enumerator class as well
// but that's often not needed:
public IEnumerator<Unit> GetEnumerator() {
   return this.units.GetEnumerator();
}

IEnumerator IEnumerable.GetEnumerator() {
   returm GetEnumerator();
   }
 }
 static void Main() {
    var unitCamp = new UnitCamp();
    unitCamp.TrainUnit();
// we can use foreach on an instance of Unitcamp:
foreach (var unit in UnitCamp) {
}
```

- Works for all Collections!
- More speficically, for those that implement IEnumerable or IEnumerable<T>

---
